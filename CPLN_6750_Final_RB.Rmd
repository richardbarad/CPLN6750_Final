---
title: "CPLN_Final_RB"
author: "Richard Barad"
date: "2024-04-24"
output: html_document
---

```{r setup}

library(sf)
library(tidycensus)
library(terra)
library(tidyverse)
library(tidyterra)
library(FNN)
library(gridExtra)
library(viridis)
library(kableExtra)

library(caret)
library(yardstick)
library(pscl)
library(plotROC) 
library(ggrepel)
library(pROC)

palette2 <- c("#41b6c4","#253494")
palette4 <- c("#a1dab4","#41b6c4","#2c7fb8","#253494")
palette5 <- c("#ffffcc","#a1dab4","#41b6c4","#2c7fb8","#253494")
palette10 <- c("#f7fcf0","#e0f3db","#ccebc5","#a8ddb5","#7bccc4",
               "#4eb3d3","#2b8cbe","#0868ac","#084081","#f7fcf0")

```

```{r functions}

xyC <- function(aPolygonSF) {
  as.data.frame(
    cbind(x=st_coordinates(st_centroid(aPolygonSF))[,1],
          y=st_coordinates(st_centroid(aPolygonSF))[,2]))
} 

nn_function <- function(measureFrom,measureTo,k) {
  #convert the sf layers to matrices
  measureFrom_Matrix <-
    as.matrix(measureFrom)
  measureTo_Matrix <-
    as.matrix(measureTo)
  nn <-   
    get.knnx(measureTo, measureFrom, k)$nn.dist
    output <-
    as.data.frame(nn) %>%
    rownames_to_column(var = "thisPoint") %>%
    gather(points, point_distance, V1:ncol(.)) %>%
    arrange(as.numeric(thisPoint)) %>%
    group_by(thisPoint) %>%
    summarize(pointDistance = mean(point_distance)) %>%
    arrange(as.numeric(thisPoint)) %>% 
    dplyr::select(-thisPoint) %>%
    pull()
  
  return(output)  
}

```

# Planning Rationale

Atlanta is one of the fastest growing metropolitan areas in the United States. In 2011 the city's Metropolitan Service Area (MSA) had a population of 4,544,000 people. By 2021 the population had increased to 5,911,000 people an increase of 30% in just ten years. By 2031 the population is forecasted to reach 6,662,000 people. This high population growth, has resulted in an increase in development. This development is necessary to provide homes for new residents, and additional commercial space to serve a growing population. However, urban development also creates a higher likelihood of urban sprawl, which can have detrimental impacts on the environment and result in biodiversity loss and increased storm water runoff. 

In this analysis, we will develop a model to help forecast where development could take place between 2021 and 2031. The model is first trained using information on where development took place between 2011 and 2021. The predictors used in the model include land cover, distance to nearest highway, distance to nearest developed pixels, and the county the study area is in. Multiple models are developed, and the model which has the best performance is then used to forecast where development will likely take place between 2021 and 2031. The type of model used is a logistic regression model, which is a common type of model used for forecasting land use change.

# Study Area

Our study area for this analysis is the Atlanta MSA. In total 28 counties are included in the Atlanta MSA. The map of the counties included in the study area is shown in the map below. 

```{r atl_msa}

atl_msa <- st_read('https://arcgis.atlantaregional.com/arcgis/rest/services/OpenData/FeatureServer/67/query?outFields=*&where=1%3D1&f=geojson') %>%
  st_make_valid() %>%
  st_transform('EPSG:2240') %>%
  dplyr::filter(MSA == 'Y')

atl_msa_dissolve <- st_union(atl_msa)

ggplot()+
  geom_sf(data=atl_msa,color='gray70')+
  geom_sf_text(data=atl_msa,aes(label=NAME10),size=2.5)+
  ggtitle('Map of the Study Area')+
  theme_void()

```

# Methods

## Get Land Cover Data

To start, the analysis imports land cover data for 2011 and 2021. Land Cover data comes from the National Land Cover Database (NLCD), a product produced by USGS that provides 30 x 30 meter land cover data for all of the United States.

```{r atl_landcover}

lc2011 <- terra::rast('DATA/nlcd_2011.tif')
lc2011 <- terra::project(lc2011,'EPSG:2240')

lc2021 <- terra::rast('DATA/nlcd_2021.tif')
lc2021 <- terra::project(lc2021,'EPSG:2240')

```

## Create Fishnet for 2011

Next, we create a grid of square cells that cover the entire study area. Each grid square is 2500 x 2500 square feet. The grid squares will be our unit of analysis for this study. A map of the grid squares is shown below. 

```{r create_fishnet}

fishnet <- st_make_grid(atl_msa,2500) %>%
  st_sf() %>%
  st_join(.,atl_msa,predicate='intersects',left=FALSE) %>%
  mutate(ID=row_number()) %>%
  select(ID)
 
ggplot()+
  geom_sf(data=fishnet,color='grey50',fill='gray90',linewidth=0.1)+
  geom_sf(data=atl_msa,fill='transparent',color='gray20',linewidth=0.5)+
  geom_sf_text(data=atl_msa,aes(label=NAME10),size=2.5)+
  ggtitle('Map of Grid Squares in Study Area')+
  theme_void()

```


# Land Cover Change Analysis

The Land Cover rasters obtained from the National Land Cover Database (NLCD), include 15 land cover categories. The land cover data is reclassified into five more general land cover categories. Developed, Open Space; Developed, Low Intensity; Developed, Medium Intensity; and Developed High Intensity are classified as 'Developed'. Decidious Forest, Evergreen Forest, and Mixed Forest are reclassified as Forest. Pasture and Crops are grouped into a single farm category. Woody wetlands and herbaceous wetlands are grouped together into a wetlands category and barren land, scrub, and grasslands are groupped into an 'Other Undeveloped Category'. The maps below show the resulting reclassified land cover maps for 2021 and 2011.

```{r reclassify_dev, fig.width=13, fig.height=7, warning = FALSE, message = FALSE}

land_cover_reclass_matrix = matrix(
                           c(11,0,
                             21,1,
                             22,1,
                             23,1,
                             24,1,
                             41,2,
                             42,2,
                             43,2,
                             81,3,
                             82,3,
                             90,4,
                             95,4,
                             52,5,
                             71,5,
                             31,5),
                             ncol=2,byrow = TRUE)

lc2011_class <- terra::classify(lc2011,land_cover_reclass_matrix)

levels(lc2011_class) <- c('Water','Developed','Forest','Farm','Wetlands','OtherUndeveloped')

lc2011_class_mask <- terra::mask(lc2011_class,atl_msa)

levels(lc2011_class_mask) <- c('Water','Developed','Forest','Farm','Wetlands','OtherUndeveloped')

lc2021_class <- terra::classify(lc2021,land_cover_reclass_matrix)

levels(lc2021_class) <- c('Water','Developed','Forest','Farm','Wetlands','OtherUndeveloped')

lc2021_class_mask <- terra::mask(lc2021_class,atl_msa)

levels(lc2021_class_mask) <- c('Water','Developed','Forest','Farm','Wetlands','OtherUndeveloped')

grid.arrange(ncol=2,

ggplot()+
  geom_spatraster(data=lc2011_class_mask,na.rm=TRUE)+
  geom_sf(data=atl_msa,fill='transparent',color='black',linewidth=0.5)+
  scale_fill_manual(values=c('lightblue','pink','lightgreen','lightyellow','blue','orange'),na.value = "transparent",name='Land Cover')+
  theme_void()+
  ggtitle('Land Cover in 2011'),

ggplot()+
  geom_spatraster(data=lc2021_class_mask,na.rm=TRUE)+
  geom_sf(data=atl_msa,fill='transparent',color='black',linewidth=0.5)+
  scale_fill_manual(values=c('lightblue','pink','lightgreen','lightyellow','blue','orange'),na.value = "transparent",name='Land Cover')+
  theme_void()+
  ggtitle('Land Cover in 2021')

)

```

Next, the land cover data is summarized by the grid squares in the study area and the percent of each square that is developed is calculated for both the 2021 and 2011 land cover data.  

```{r land_cover_percent_developed, fig.width=10, fig.height=5}

lc2011_extract <- terra::extract(lc2011_class,fishnet,fun=table)

lc2011_extract_df <- lc2011_extract %>%
  mutate(
    pct_developed = Developed / (Developed + Water + Forest + Farm + Wetlands + OtherUndeveloped) * 100
  )

# Combine the tables from each cell into a single data frame
#lc2011_extract_df <- do.call(rbind, lc2011_extract)

# Convert row names to a separate column and reset row names
#lc2011_extract_df <- data.frame(ID = rownames(lc2011_extract_df), lc2011_extract_df)
#rownames(lc2011_extract_df) <- NULL

# Remove the erroneous first row (if present)
#lc2011_extract_df <- lc2011_extract_df[-1, ]

#lc2011_extract_df <- lc2011_extract_df %>%
#  mutate(ID = row_number())

#lc2011_extract_df <- lc2011_extract_df %>%
#  mutate(
#    pct_developed = Developed / (Developed + Water + Forest + Farm + Wetlands + OtherUndeveloped) * 100
#  )
```


```{r land_cover_percent_developed, fig.width=10, fig.height=5}

lc2021_extract <- terra::extract(lc2021_class,fishnet,fun=table)

lc2021_extract_df <- lc2021_extract %>%
  mutate(
    pct_developed2021 = Developed / (Developed + Water + Forest + Farm + Wetlands + OtherUndeveloped) * 100
  )

# Combine the tables from each cell into a single data frame
#lc2021_extract_df <- do.call(rbind, lc2021_extract)

# Convert row names to a separate column and reset row names
#lc2021_extract_df <- data.frame(ID = rownames(lc2021_extract_df), lc2021_extract_df)
#rownames(lc2021_extract_df) <- NULL

# Remove the erroneous first row (if present)
#lc2021_extract_df <- lc2021_extract_df[-1, ]

#lc2021_extract_df <- lc2021_extract_df %>%
#  mutate(ID = row_number())

#lc2021_extract_df <- lc2021_extract_df %>%
#  mutate(
#    pct_developed2021 = Developed / (Developed + Water + Forest + Farm + Wetlands + OtherUndeveloped) * 100
#  )
```


The maps below show the percent of each grid square that is developed in 2011 and 2021. Grid square that are more developed are shown in a brighter color, while grid square that are not developed are shown in a dark color. 

```{r land_cover_percent_developed, fig.width=10, fig.height=5}
fishnet_pct_developed <- cbind(fishnet,lc2011_extract_df %>% select(pct_developed),lc2021_extract_df %>% select(pct_developed2021)) %>%
  mutate(change = pct_developed2021 - pct_developed)

grid.arrange(ncol=2,

ggplot(data=fishnet_pct_developed)+
  geom_sf(aes(fill=pct_developed),color='transparent')+
  scale_fill_viridis(option='rocket',name='Percent Developed')+
  geom_sf(data=atl_msa,fill='transparent',color='white',linewidth=0.5)+
  theme_void()+
  ggtitle('Percent Developed in 2011'),

ggplot(data=fishnet_pct_developed)+
  geom_sf(aes(fill=pct_developed2021),color='transparent')+
  scale_fill_viridis(option='rocket',name='Percent Developed')+
  geom_sf(data=atl_msa,fill='transparent',color='white',linewidth=0.5)+
  theme_void()+
  ggtitle('Percent Developed in 2021')
)
  
```

Next, we set a threshold for what percent developed is considered a developed area. In this analysis, a grid square is classified as developed if it is more than 25% developed. The maps below show the grid squares that are developed in 2011 and 2021 and the grid squares that changed their development status between 2011 and 2021. 

``` {r identify_developed, fig.width=13, fig.height=7}

fishnet_pct_developed <- fishnet_pct_developed %>%
  mutate(developed2011 = as.factor(ifelse(pct_developed > 25,1,0)),
         developed2021 = as.factor(ifelse(pct_developed2021 > 25,1,0)),
         lc_change = as.factor(ifelse(developed2011 == 0 & developed2021 == 1 & change > 5,1,0)))

grid.arrange(ncol=3,

ggplot(data=fishnet_pct_developed)+
  geom_sf(aes(fill=developed2011),color='transparent')+
  scale_fill_manual(values=c('gray95','pink'),labels=c('Not Developed','Developed'),name='')+
  geom_sf(data=atl_msa,fill='transparent',color='black',linewidth=0.5)+
  theme_void()+
  ggtitle('Developed Pixels Grid Squares in 2011'),

ggplot(data=fishnet_pct_developed)+
  geom_sf(aes(fill=developed2021),color='transparent')+
  scale_fill_manual(values=c('gray95','pink'),labels=c('Not Developed','Developed'),name='')+
  geom_sf(data=atl_msa,fill='transparent',color='black',linewidth=0.5)+
  theme_void()+
  ggtitle('Developed Grid Squares in 2021'),

ggplot(data=fishnet_pct_developed)+
  geom_sf(aes(fill=lc_change),color='transparent')+
  scale_fill_manual(values=c('gray95','green'),labels=c('No Change','Change'),name='')+
  geom_sf(data=atl_msa,fill='transparent',color='black',linewidth=0.5)+
  theme_void()+
  ggtitle('Grid Squares with a Change in Development')
)

```

# Add Predictors to 2011 Fishnet

Next, we add data to hte grid squares for the predictors that will be used to train the model.

## Land Cover

The first predictor we work with is land cover data. The dominant land cover class in each of the grid squares is determined - all undeveloped grid squares are classified as either water, forest, farm, wetlands, or other undeveloped. Additionally, the percent of each grid square that is farm, forest, wetlands, and other undeveloped are also calculated. When building models, we will train models using the percent land cover data and the dominant land cover class to see which type of land cover variable has more predictive power and produces a better fit model.

```{r}

fishnet_2011 <- cbind(lc2011_extract_df,fishnet_pct_developed %>% select(developed2011,lc_change)) %>%
  rename(developed = developed2011) %>%
  rowwise() %>% mutate(max = max(c(Forest,Farm,Wetlands,Water,OtherUndeveloped,Developed))) %>%
  ungroup() %>%
  st_as_sf() %>%
  mutate(water=as.factor(ifelse(max==Water,1,0)),
         forest=as.factor(ifelse(max==Forest,1,0)),
         farm=as.factor(ifelse(max==Farm,1,0)),
         wetlands=as.factor(ifelse(max==Wetlands,1,0)),
         otherundeveloped=as.factor(ifelse(max==OtherUndeveloped,1,0)),
         pct_forest = Forest / (Developed + Water + Forest + Farm + Wetlands + OtherUndeveloped) * 100,
         pct_farm = Farm / (Developed + Water + Forest + Farm + Wetlands + OtherUndeveloped) * 100,
         pct_wetlands = Wetlands / (Developed + Water + Forest + Farm + Wetlands + OtherUndeveloped) * 100,
         pct_other = OtherUndeveloped / (Developed + Water + Forest + Farm + Wetlands + OtherUndeveloped) * 100) %>%
  select(ID,water,forest,farm,wetlands,otherundeveloped,lc_change,developed,pct_forest,pct_farm,pct_wetlands,pct_other,geometry)

```

## Distance to Nearest Developed Cell

Next we calculated, the average distance in feet from the center of each grid square to the center of the nearest 5 and the nearest 10 developed cells. This is a useful variable to include in the model, because development often tends to cluster in space with new development taking place near existing development sites. The map below shows the average distance in feet to the ten nearest developed cells. As shown, the distance to other developed cells to be smaller near the urban core and is higher in the periphery of the MSA.

``` {r}

fishnet_2011$lagDevelopment_5 <- nn_function(xyC(fishnet_2011),xyC(filter(fishnet_2011,developed==1)),5)
fishnet_2011$lagDevelopment_10 <- nn_function(xyC(fishnet_2011),xyC(filter(fishnet_2011,developed==1)),10)

ggplot()+
  geom_sf(data=fishnet_2011,aes(fill=lagDevelopment_10),color='transparent')+
  geom_sf(data=atl_msa,color='black',linewidth=0.5,fill='transparent')+
  scale_fill_viridis_c(option='virdis',name='Spatial Lag to Development (feet)')+
  labs(title = "Average Distance to 10 Nearest Developed Cells")+
  theme_void()

```


## Population Data

```{r load_key, echo=FALSE, warning = FALSE, eval = FALSE}
census_api_key("ab9309f9cc70c0e1895e7166c3ca981c40cf0331", overwrite = TRUE , install = TRUE)
```

Next, we add population data to the fishnet grid. First, population data is downloaded at the Tract Level, and is downloaded from the American Community Survey (ACS) dataset. Population data is downloaded for both 2011 and 2021. 

```{r, warning = FALSE, message = FALSE, results = "hide"}
atlantaPop11 <- 
  get_acs(geography = "tract", variables = "B01003_001", year = 2011,
                state = 13, geometry = TRUE, 
                county=c("Fayette","Carroll","Rockdale","Cobb","Forsyth",
                         "Clayton","Henry","Dawson","Bartow","Lamar","Haralson","Meriwether","Newton","Gwinnett","Fulton","Pickens","Spalding","Douglas","Coweta","Heard","Butts","Jasper","DeKalb", "Cherokee","Walton","Pike","Barrow","Paulding")) %>%
  rename(pop_2011 = estimate) %>%
  st_transform(st_crs(atl_msa))

atlantaPop21 <- 
  get_acs(geography = "tract", variables = "B01003_001", year = 2021,
                state = 13, geometry = TRUE, 
                county=c("Fayette","Carroll","Rockdale","Cobb","Forsyth",
                         "Clayton","Henry","Dawson","Bartow","Lamar","Haralson","Meriwether","Newton","Gwinnett","Fulton","Pickens","Spalding","Douglas","Coweta","Heard","Butts","Jasper","DeKalb", "Cherokee","Walton","Pike","Barrow","Paulding")) %>%
  rename(pop_2021 = estimate) %>%
  st_transform(st_crs(atl_msa)) %>%
  st_buffer(-1)
```
The maps below show the population data by census tract in 2011 and 2021. 

```{r, warning = FALSE, message = FALSE, fig.height= 8, fig.width= 11}
grid.arrange(
ggplot() +
  geom_sf(data = atlantaPop11, aes(fill=pop_2011), colour=NA) +
  scale_fill_viridis(option='rocket',name='Population 2011',direction=-1)+
  labs(title="Population, Atlanta MSA: 2011") +
  theme_void(),

ggplot() +
  geom_sf(data = atlantaPop21, aes(fill=pop_2021), colour=NA) +
  scale_fill_viridis(option='rocket',name='Population 2021',direction=-1)+
  labs(title="Population, Atlanta MSA: 2021") +
  theme_void(), ncol=2)
```

Next, the population in each census tract is spread out across the grid scales located in the census tract. We assign a proportion of a tractâ€™s population to a grid cell weighted by the proportion of the tract that intersects the grid cell. Here we are assuming that, the population is distributed equally across the census tract. This is likely not the case, but it is a reasonable assumption to make for our use case. Since population is just being used as a predictor in the model, it does not need to be measured precisely. 

```{r, warning = FALSE, message = FALSE}

fishnet_2011 <-
  st_interpolate_aw(atlantaPop11["pop_2011"], fishnet_2011, extensive=TRUE) %>%
  st_drop_geometry() %>%
  rownames_to_column(var = "ID") %>%
  left_join(fishnet_2011 %>%
              mutate(ID = as.character(ID)),.,
            by=c('ID'='ID')) %>% 
  mutate(pop = replace_na(pop_2011,0))

```


## Distance from Road

Next, the distance from the center of each grid square to the nearest interstate highway is added to the fishnet. The distance is measure in feet and the map below shows the grid squares colored according to thier distance from the nearest highway. The highways are shown in red. 

``` {r}

highways <- st_read('./Data/Expressways_Atlanta_Region.geojson') %>% st_transform('EPSG:2240')

centroid <- fishnet_2011 %>%
  st_centroid()

nearest_feat <- st_nearest_feature(centroid,highways)

fishnet_2011$highway_dist <- as.double(st_distance(centroid, highways[nearest_feat,], by_element=TRUE))

ggplot()+
  geom_sf(data=fishnet_2011,aes(fill=highway_dist),color='transparent')+
  scale_fill_viridis_c(name='Distance to Highway feet')+
  geom_sf(data=highways,color='red')+
  theme_void()

```

## Join Counties

Next, each grid square is associated with a county. The county the grid square is part of is determined based on what grid square has a majority overlap with the county boundaries. Additionally, grid squares that are water or are allready developed are removed the fishnet that will be used to train the model. Developed grid squares are removed because if a grid square is allready developed it is not able to develop again. 

``` {r}

fishnet_2011 <- st_join(fishnet_2011,atl_msa %>% rename (county = NAME10) %>% select(county),largest=TRUE) %>%
  filter(water == 0) %>%
  filter(developed == 0) 
  
```

# Data Exploration

The next steps of the analysis involves exploring our data. The chart below shows the number of grid squares in the dataset that developed and did not develop. As shown, the number of grid square that changed development status are quite small when compared to the number that did not change development status. 

```{r count_positives}

ggplot(data=fishnet_2011)+
  geom_bar(aes(x=lc_change,fill=lc_change),stat='count')+
  scale_fill_manual(values=palette2,labels=c('No Development','Development Change'))+
  scale_x_discrete(labels=c('No Change','Development Change'),name='Development Change')+
  scale_y_continuous(name='Number of Grid Squares')+
  theme_bw()+
  ggtitle('Number of Grid Squares that Developed and Did Not Develop')

```


```{r, warning = FALSE, message = FALSE}
fishnet_2011 %>%
  dplyr::select(highway_dist,lagDevelopment_5,lagDevelopment_10, lc_change) %>%
  gather(Variable, Value, -lc_change, -geometry) %>%
  ggplot(., aes(lc_change, Value, fill=lc_change)) + 
    geom_bar(position = "dodge", stat = "summary", fun.y = "mean") +
    facet_wrap(~Variable) +
    scale_fill_manual(values = palette2,
                      labels=c("No Development","Development Change"),
                      name="") +
    labs(title="New Development as a Function of Distance to Road and Distance to Nearest Development") +
    theme_bw()
```


```{r, warning = FALSE, message = FALSE}
fishnet_2011 %>%
  dplyr::select(pop,lc_change) %>%
  gather(Variable, Value, -lc_change, -geometry) %>%
  ggplot(., aes(lc_change, Value, fill=lc_change)) + 
    geom_bar(position = "dodge", stat = "summary", fun.y = "mean") +
    facet_wrap(~Variable) +
    scale_fill_manual(values = palette2,
                      labels=c("No Development","Development Change"),
                      name="") +
    labs(title="New Development as a Function of Population") +
    theme_bw()
```


```{r, warning = FALSE, message = FALSE}
fishnet_2011 %>%
  dplyr::select(pct_farm, pct_forest, pct_wetlands, pct_other, lc_change) %>%
  gather(Variable, Value, -lc_change, -geometry) %>%
  ggplot(., aes(lc_change, Value, fill=lc_change)) + 
    geom_bar(position = "dodge", stat = "summary", fun.y = "mean") +
    facet_wrap(~Variable) +
    scale_fill_manual(values = palette2,
                      labels=c("No Development","Development Change"),
                      name="") +
    labs(title="New Development as a Function of Percent Land Cover Variables") +
    theme_bw()
```



```{r, warning = FALSE, message = FALSE}
fishnet_2011 %>%
  dplyr::select(lc_change:otherundeveloped,water, forest, farm, wetlands) %>%
  gather(Land_Cover_Type, Value, -lc_change, -geometry) %>%
   st_set_geometry(NULL) %>%
     group_by(lc_change, Land_Cover_Type) %>%
     summarize(n = sum(as.numeric(Value))) %>%
     ungroup() %>%
    mutate(Conversion_Rate = paste0(round(100 * n/sum(n), 2), "%")) %>%
    filter(lc_change == 1) %>%
  dplyr::select(Land_Cover_Type,Conversion_Rate) %>%
  kable() %>% kable_styling(full_width = F)
```


# Modelling

## Build Model

Undersample the 0s

```{r}

undersample_2011 <- fishnet_2011 %>% 
  filter(lc_change == 0) %>% 
  sample_frac(.2) %>%
  rbind(.,fishnet_2011 %>% filter(lc_change == 1))

ggplot(data=undersample_2011)+
  geom_bar(aes(x=lc_change,fill=lc_change),stat='count')+
  scale_fill_manual(values=palette2,labels=c('No Development','Development Change'))+
  scale_x_discrete(labels=c('No Development','Development Change'),name='Development Change')+
  scale_y_continuous(name='Number of Grid Squares')+
  theme_bw()+
  ggtitle('Number of Grid Squares that Developed and Did Not Develop after Under sampling 0s')

```


Split into training and test dataset.

```{r, warning = FALSE, message = FALSE}
set.seed(3456)

trainIndex <- createDataPartition(undersample_2011$developed, p = .75,list = FALSE,times = 1)

datTrain <- undersample_2011[ trainIndex,]
datTest  <- undersample_2011[-trainIndex,]

```


Build For Different Models

```{r models}

Model1 <- glm(lc_change ~ wetlands + forest  + farm + otherundeveloped ,
              family="binomial"(link="logit"), data = datTrain)

Model2 <- glm(lc_change ~ wetlands + forest  + farm + otherundeveloped + lagDevelopment_5 + pop + highway_dist + county,
              family="binomial"(link="logit"), data = datTrain)

Model3 <- glm(lc_change ~ wetlands + forest  + farm + otherundeveloped + lagDevelopment_10 + pop + highway_dist + county, 
              family="binomial"(link="logit"), data = datTrain)
              
Model4 <- glm(lc_change ~ pct_wetlands + pct_forest  + pct_farm + pct_other + lagDevelopment_5 + pop + highway_dist + county, 
              family="binomial"(link="logit"), data = datTrain)          
              
Model5 <- glm(lc_change ~ pct_wetlands + pct_forest  + pct_farm + pct_other + lagDevelopment_10 + pop + highway_dist + county,
              family="binomial"(link="logit"), data = datTrain)   

```


```{r, warning = FALSE, message = FALSE}
modelList <- paste0("Model", 1:5)
map_dfc(modelList, function(x)pR2(get(x)))[4,] %>%
  setNames(paste0("Model",1:5)) %>%
  gather(Model,McFadden) %>%
  ggplot(aes(x=Model,y=McFadden)) +
    geom_bar(stat="identity",fill='orange') +
    geom_text(aes(label=round(McFadden,2),y= McFadden - 0.01))+
    labs(title= "McFadden R-Squared by Model")+
  theme_bw()
```
```{r}

summary(Model5)

```

Next, a data frame is created that includes columns for the observed development change, `lc_change`, and one that includes predicted probabilities for `Model5`.

```{r, warning = FALSE, message = FALSE}
testSetProbs <- 
  data.frame(class = datTest$lc_change,
             probs = predict(Model5, datTest, type="response")) 
  
ggplot(testSetProbs) +
  geom_density(alpha=0.5,aes(x=probs,fill=class))+
  scale_fill_manual(values = palette2,
                    labels=c("No Change","New Development")) +
  facet_wrap(~class)+
  labs(title = "Histogram of test set predicted probabilities",
       x="Predicted Probabilities",y="Density")+
  theme_bw()
```

## ROC Curve

```{r ROC_Curve}

auc <- round(auc(testSetProbs$class,testSetProbs$probs),4)

ggplot(data=testSetProbs,aes(d=as.numeric(class),m=probs))+
  geom_roc(n.cuts=50,color='orange',labels=FALSE)+
  annotate("text", x = 0.1, y = 1, label=paste("AUC: ",as.character(auc)),color='orange')+
  theme_bw()


```

## Accuracy

```{r, warning = FALSE, message = FALSE}
options(yardstick.event_first = FALSE)

testSetProbs <- 
  testSetProbs %>% 
  mutate(predClass_05 = as.factor(ifelse(testSetProbs$probs >= 0.05 ,1,0)),
         predClass_10 = as.factor(ifelse(testSetProbs$probs >= 0.10 ,1,0)),
         predClass_15 = as.factor(ifelse(testSetProbs$probs >= 0.15 ,1,0)),
         predClass_20 = as.factor(ifelse(testSetProbs$probs >= 0.20 ,1,0)),
         predClass_25 = as.factor(ifelse(testSetProbs$probs >= 0.25 ,1,0)),
         predClass_30 = as.factor(ifelse(testSetProbs$probs >= 0.30 ,1,0))) 

testSetProbs %>%
  dplyr::select(-probs) %>%
  gather(Variable, Value, -class) %>%
  group_by(Variable) %>%
  summarize(Sensitivity = round(yardstick::sens_vec(class,factor(Value)),2),
            Specificity = round(yardstick::spec_vec(class,factor(Value)),2),
            Accuracy = round(yardstick::accuracy_vec(class,factor(Value)),2)) %>% 
  kable() %>%
  kable_styling(full_width = F)
```

## Generalizability

```{r generlize_county, , fig.height= 8, fig.width= 11}

county_errors <- cbind(datTest,testSetProbs %>% select(class,predClass_10)) %>%
  mutate(type = case_when(class == '1' & predClass_10 == '1' ~ 'TP',
                         class == '0' & predClass_10 == '0' ~ 'TN',
                         class == '0' & predClass_10 == '1' ~ 'FP',
                         class == '1' & predClass_10 == '0' ~ 'FN')) %>%
  st_drop_geometry() %>%
  group_by(county,type) %>% tally() %>%
  pivot_wider(names_from=type,values_from=n) %>%
  replace(is.na(.),0) %>%
  left_join(atl_msa,.,by=join_by('NAME10'=='county')) %>%
  mutate(sensitivity = round(TP / (FN + TP) * 100,1),
         specificity = round(TN / (TN + FP) *100),1) %>%
  select(NAME10,sensitivity,specificity)

grid.arrange(

ggplot(data=county_errors)+
  geom_sf(aes(fill=sensitivity),color='gray30')+
  scale_fill_distiller(palette='Greens',name='Sensisitvity',na.value='gray50')+
  geom_sf_text(aes(label=NAME10),size=3)+
  labs(title='Sensitivity by County',subtitle='Gray Indicates No Data')+
  theme_void(),
  
ggplot(data=county_errors)+
  geom_sf(aes(fill=specificity),color='gray30')+
  scale_fill_distiller(palette='Greens',name='Specificity',na.value='gray50')+
  geom_sf_text(aes(label=NAME10),size=3)+
  labs(title='Specificity by County')+
  theme_void(),

nrow=1
  
)

```

## Cross Validation

```{r cross_validation}


#Cross Validation Needed a Text Field
undersample_2011 <- undersample_2011 %>%
  mutate(lc_change_text = ifelse(lc_change == 1,'Change','No.Change'))

ctrl <- trainControl(method = "cv", number = 50, classProbs = TRUE, savePredictions = TRUE, summaryFunction = twoClassSummary)

cvFit <- train(
  lc_change_text ~ pct_wetlands + pct_forest  + pct_farm + pct_other + lagDevelopment_10 + pop + highway_dist + county,
  data = undersample_2011,
  method = "glm",
  family = "binomial",
  trControl = ctrl
)

# Manually calculated Sensitivity and Specificity as train defaulted to using a threshold of 0.5 and could not figure out how to manually set threshold 
pred <- cvFit$pred %>%
  mutate(Change = round(1 - No.Change,2),
    pred = (ifelse(Change > 0.10,'Change','No.Change')),
        type = case_when(pred == 'Change' & obs == 'Change' ~ 'TP',
                         pred == 'No.Change' & obs == 'No.Change' ~ 'TN',
                         pred == 'Change' & obs == 'No.Change' ~ 'FP',
                         pred == 'No.Change' & obs == 'Change' ~ 'FN')) %>%
  group_by(Resample,type) %>% tally %>%
  spread(key=type,value=n) %>%
  replace(is.na(.), 0) %>%
  mutate(Sensitivity = TP / (TP + FN),
         Specificity = TN / (FP + TN),
         Accuracy = (TP + TN) / (TP + TN + FP + FN)) %>%
  dplyr::select('Sensitivity','Specificity','Accuracy') %>%
  pivot_longer(.,cols=-Resample,names_to='metric',values_to='value')

ggplot(data=pred,aes(value)) + 
  geom_histogram(bins=50, fill = '#E4002B',color='gray60',linewidth=0.1)+
  facet_wrap(~metric) +
  scale_x_continuous(limits = c(0, 1)) +
  labs(x="Goodness of Fit", y="Count", title="Histogram of Cross Validation Model Fit Metrics")+
  theme_bw()

```

# Build Fishnet for 2021

## Identify Dominant Land Cover Class 

```{r}

fishnet_2021 <- cbind(lc2021_extract_df,fishnet_pct_developed %>% select(developed2021)) %>%
  rename(developed = developed2021) %>%
  rowwise() %>% mutate(max = max(c(Forest,Farm,Wetlands,Water,OtherUndeveloped))) %>%
  ungroup() %>%
  mutate(water=as.factor(ifelse(max==Water,1,0)),
         forest=as.factor(ifelse(max==Forest,1,0)),
         farm=as.factor(ifelse(max==Farm,1,0)),
         wetlands=as.factor(ifelse(max==Wetlands,1,0)),
         otherundeveloped=as.factor(ifelse(max==OtherUndeveloped,1,0)),
         pct_forest = Forest / (Developed + Water + Forest + Farm + Wetlands + OtherUndeveloped) * 100,
         pct_farm = Farm / (Developed + Water + Forest + Farm + Wetlands + OtherUndeveloped) * 100,
         pct_wetlands = Wetlands / (Developed + Water + Forest + Farm + Wetlands + OtherUndeveloped) * 100,
         pct_other = OtherUndeveloped / (Developed + Water + Forest + Farm + Wetlands + OtherUndeveloped) * 100) %>%
  select(ID,water,forest,farm,wetlands,otherundeveloped,developed,pct_forest,pct_farm,pct_wetlands,pct_other,geometry) %>%
  st_as_sf()

```


## Spatial Lag of Development and Road Distance

``` {r}

fishnet_2021$lagDevelopment_5 <- nn_function(xyC(fishnet_2021),xyC(filter(fishnet_2021,developed==1)),5)
fishnet_2021$lagDevelopment_10 <- nn_function(xyC(fishnet_2021),xyC(filter(fishnet_2021,developed==1)),10)

fishnet_2021$highway_dist <- as.double(st_distance(centroid, highways[nearest_feat,], by_element=TRUE))

```

## Add Population

```{r}

fishnet_2021 <-
  st_interpolate_aw(atlantaPop21["pop_2021"], fishnet_2021, extensive=TRUE) %>%
  st_drop_geometry() %>%
  rownames_to_column(var = "ID") %>%
  left_join(fishnet_2021 %>%
              mutate(ID = as.character(ID)),
            ., by=c("ID"='ID')) %>% 
  mutate(pop = replace_na(pop_2021,0))

```

## Join Counties

``` {r}

fishnet_2021_dev <- fishnet_2021 %>% filter(developed==1)

fishnet_2021 <- st_join(fishnet_2021,atl_msa %>% rename (county = NAME10) %>% select(county),largest=TRUE) %>%
  filter(water==0) %>%
  filter(developed==0)
  
```

# Predictitions for 2031

## Part 1

The map below shows where development is forecasted to take place. Grid squares that are predicted to convert to developed grid squares between 2021 and 2031 are shown in red, while grid squares that are not expected to convert are shown in green. The chart on the right shows the number of grid squares by that are predicted to convert by land cover type. Overall, the majority of grid cells that are predicted to convert are forested cells.

```{r fig.width=12,fig.height=5}
fishnet_2021_results <- fishnet_2021 %>%
  mutate(probs=predict(Model5,fishnet_2021,type='response'),
         outcome=as.factor(ifelse(probs>=0.1,1,0)))

fishnet_2021_type <- fishnet_2021_results %>%
  select(ID,forest,farm,wetlands,otherundeveloped,outcome) %>%
  st_drop_geometry() %>%
  pivot_longer(cols=c(-outcome,-ID),names_to='Type',values_to='Land_Cover') %>%
  filter(Land_Cover == 1) %>%
  filter(outcome == 1)

grid.arrange(
  
ggplot()+
  geom_sf(data=fishnet_2021_dev,fill='gray70',color='transparent')+
  geom_sf(data=fishnet_2021_results,aes(fill=outcome),color='transparent')+
  geom_sf(data=atl_msa,color='gray40',linewidth=0.5,fill='transparent')+
  scale_fill_manual(values=c('#baffaa','#fc6a6e'),name='Predicted Outcome',labels=c('No Development Change','Development Change'))+
  geom_sf_text(data=atl_msa,aes(label=NAME10),size=3)+
  ggtitle('Map of Predictions for 2031')+
  theme_void(),

ggplot(data=fishnet_2021_type)+
  geom_bar(aes(x=Type,fill=Type),stat='Count')+
  scale_fill_manual(values=c('yellow','lightgreen','orange','lightblue'),na.value = "transparent",name='Land Cover')+
  ggtitle('Type of Land Cover Grid Squares Predicted to Change')+
  scale_x_discrete('Type of Land Cover')+
  theme_bw(),

nrow=1,
widths=c(3,4)
)


```


## Part 2

```{r fig.width=12,fig.height=5}

fishnet_2021_s2 <- fishnet_2021

centroid2 <- fishnet_2021_s2 %>%
  st_centroid()

new_highways <- st_read('./Data//Expressways_Atlanta_Region/Expressways_Atlanta_Region.shp') %>% st_transform('EPSG:2240') %>%
  mutate(last_edite=ifelse(is.na(last_edite),'Other','SDE'))

new_nearest_feat <- st_nearest_feature(centroid2,new_highways)

fishnet_2021_s2$highway_dist <- as.double(st_distance(centroid2, new_highways[new_nearest_feat,], by_element=TRUE))
```

## Prediction for Scenario 2

```{r fig.width=12,fig.height=5}
fishnet_2021_results_s2 <- fishnet_2021_s2_s2 %>%
  mutate(probs=predict(Model5,fishnet_2021_s2_s2,type='response'),
         outcome=as.factor(ifelse(probs>=0.1,1,0)))

ggplot()+
  geom_sf(data=fishnet_2021_dev_s2,fill='gray70',color='transparent')+
  geom_sf(data=fishnet_2021_results_s2,aes(fill=outcome),color='transparent')+
  geom_sf(data=atl_msa,color='gray40',linewidth=0.5,fill='transparent')+
  geom_sf(data=new_highways,aes(color=last_edite))+
  scale_fill_manual(values=c('#baffaa','#fc6a6e'),name='Predicted Outcome',labels=c('No Development Change','Development Change'))+
  scale_color_manual(values=c('red','purple'),labels=c('New Highway','Existing Highway'),name='Highways')+
  geom_sf_text(data=atl_msa,aes(label=NAME10),size=3)+
  ggtitle('Map of Predictions for New Consturction Project')+
  theme_void()

```
